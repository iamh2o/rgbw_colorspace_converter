<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyramidtriangles.playlist API documentation</title>
<meta name="description" content="Playlists are created as an optional way to set up a looped sequence of shows to run. It the
playlist is not used, a random show will be selected when …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyramidtriangles.playlist</code></h1>
</header>
<section id="section-intro">
<p>Playlists are created as an optional way to set up a looped sequence of shows to run. It the
playlist is not used, a random show will be selected when one show is ending.</p>
<p>A playlist may contain multiple entries of the same show. Each playlist entry for a show may
contain different settings. A playlist might contain FuckYourBurn in green, then FuckYourBurn
again in purple at a higher speed.</p>
<p>The database used for playlists is in-memory and automatically created. It is destroyed when the
process exits.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Playlists are created as an optional way to set up a looped sequence of shows to run. It the
playlist is not used, a random show will be selected when one show is ending.

A playlist may contain multiple entries of the same show. Each playlist entry for a show may
contain different settings. A playlist might contain FuckYourBurn in green, then FuckYourBurn
again in purple at a higher speed.

The database used for playlists is in-memory and automatically created. It is destroyed when the
process exits.
&#34;&#34;&#34;
from __future__ import annotations
import json
import sqlite3
from contextlib import closing
from typing import Optional, Union

HSVValues = dict[str, float]
# setting_value can be int, float, or an HSV triple
Value = Union[int, float, HSVValues]
# setting_name -&gt; setting_value
Settings = dict[str, Value]

# At least one connection must be retained to the in-memory database or it will be cleared.
_db_conn_keep_open: sqlite3.Connection


class Playlist:
    &#34;&#34;&#34;
    Controller to handle in-memory database lookups for playlists.

    This class and methods are thread-safe. At least one connection must be kept open for the DB to stay in memory.
    &#34;&#34;&#34;

    @staticmethod
    def _connect() -&gt; sqlite3.Connection:
        return sqlite3.connect(&#39;file::memory:?cache=shared&#39;, timeout=0.5, uri=True)

    @classmethod
    def setup_database(cls):
        &#34;&#34;&#34;Needs to be called once to set up the database.&#34;&#34;&#34;
        global _db_conn_keep_open
        _db_conn_keep_open = cls._connect()
        with _db_conn_keep_open as conn:
            # Pragmas to increase performance from defaults
            conn.execute(&#34;PRAGMA journal_mode = &#39;WAL&#39;&#34;)
            conn.execute(&#39;PRAGMA temp_store = 2&#39;)
            conn.execute(&#39;PRAGMA synchronous = OFF&#39;)  # Use NORMAL if persisting DB
            conn.execute(&#39;PRAGMA cache_size = -64000&#39;)
            conn.execute(&#39;CREATE TABLE IF NOT EXISTS Playlist (show TEXT NOT NULL, settings TEXT)&#39;)
            conn.execute(&#39;CREATE TABLE IF NOT EXISTS Current (playing INTEGER, FOREIGN KEY (playing) REFERENCES Playlist(ROWID))&#39;)
            conn.execute(&#39;INSERT INTO Current VALUES (NULL)&#39;)

    def current_playlist(self) -&gt; list[tuple[int, str]]:
        &#34;&#34;&#34;
        Returns the current playlist of shows. [(id, show),...].
        Uses a list instead of dict to retain ordering.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            cursor = conn.execute(&#39;SELECT rowid, show FROM Playlist ORDER BY rowid&#39;)
            return cursor.fetchall()

    def current_entry(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Returns the entry_id of the playing show, or None.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            cursor = conn.execute(&#39;SELECT playing FROM Current LIMIT 1&#39;)
            return cursor.fetchone()[0]

    def next(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Gets the next show from the playlist.

        Uses the &#39;Current&#39; table to determine the next show on the playlist, and advances the Current show.
        If the Current show is NULL, selects the first item in the playlist.
        If the playlist is empty, returns None.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:  # context manager on the connection
            # Get next show from database.
            cursor = conn.execute(&#39;&#39;&#39;SELECT rowid, show FROM Playlist WHERE rowid &gt;
                IFNULL((SELECT playing FROM Current LIMIT 1),-1)
                LIMIT 1&#39;&#39;&#39;)
            next_show = cursor.fetchone()

            # Handle looping to the first show if we&#39;ve reached the end of the playlist.
            if next_show is None:
                cursor.execute(&#39;SELECT rowid, show FROM Playlist ORDER BY rowid LIMIT 1&#39;)
                next_show = cursor.fetchone()

            # next_show could still be None if Playlist is also empty
            if next_show is None:
                return None

            (entry_id, show) = next_show
            with conn:
                cursor.execute(&#39;UPDATE Current SET playing = (?)&#39;, (entry_id,))
            return show

    def set_next(self, entry_id: int) -&gt; None:
        &#34;&#34;&#34;
        Sets the next show in the playlist to be {entry_id}.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            # Get previous show from database.
            cursor = conn.execute(&#39;SELECT MAX(rowid) FROM Playlist WHERE rowid &lt; (?) LIMIT 1&#39;, (entry_id,))
            prev_id = cursor.fetchone()[0]
            with conn:
                cursor.execute(&#39;UPDATE Current SET playing = (?)&#39;, (prev_id,))

    def append(self, show: str) -&gt; int:
        &#34;&#34;&#34;
        Appends a show to the playlist and returns the new entry_id.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            with conn:
                cursor = conn.execute(&#39;INSERT INTO Playlist VALUES (?, NULL)&#39;, (show,))
                return cursor.lastrowid

    def delete(self, entry_id: int) -&gt; None:
        &#34;&#34;&#34;
        Deletes a show from the playlist.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            with conn:
                conn.execute(&#39;DELETE FROM Playlist WHERE rowid = (?)&#39;, (entry_id,))

    def clear(self) -&gt; None:
        &#34;&#34;&#34;
        Clears the whole playlist.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            with conn:
                cursor = conn.execute(&#39;DELETE FROM Playlist&#39;)
                cursor.execute(&#39;UPDATE Current SET playing = NULL&#39;)

    def get_settings(self, entry_id: int) -&gt; Settings:
        &#34;&#34;&#34;
        Returns the settings for a playlist entry, if any.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            cursor = conn.execute(&#39;SELECT settings FROM Playlist WHERE rowid = (?)&#39;, (entry_id,))
            data = cursor.fetchone()[0]
            return {} if data is None else json.loads(data)

    def set_settings(self, entry_id: int, settings: Settings) -&gt; None:
        &#34;&#34;&#34;
        Sets settings for a playlist entry.
        &#34;&#34;&#34;
        data = json.dumps(settings)
        with closing(self._connect()) as conn:
            with conn:
                conn.execute(&#39;UPDATE Playlist SET settings = (?) WHERE rowid = (?)&#39;, (data, entry_id))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyramidtriangles.playlist.Playlist"><code class="flex name class">
<span>class <span class="ident">Playlist</span></span>
</code></dt>
<dd>
<div class="desc"><p>Controller to handle in-memory database lookups for playlists.</p>
<p>This class and methods are thread-safe. At least one connection must be kept open for the DB to stay in memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Playlist:
    &#34;&#34;&#34;
    Controller to handle in-memory database lookups for playlists.

    This class and methods are thread-safe. At least one connection must be kept open for the DB to stay in memory.
    &#34;&#34;&#34;

    @staticmethod
    def _connect() -&gt; sqlite3.Connection:
        return sqlite3.connect(&#39;file::memory:?cache=shared&#39;, timeout=0.5, uri=True)

    @classmethod
    def setup_database(cls):
        &#34;&#34;&#34;Needs to be called once to set up the database.&#34;&#34;&#34;
        global _db_conn_keep_open
        _db_conn_keep_open = cls._connect()
        with _db_conn_keep_open as conn:
            # Pragmas to increase performance from defaults
            conn.execute(&#34;PRAGMA journal_mode = &#39;WAL&#39;&#34;)
            conn.execute(&#39;PRAGMA temp_store = 2&#39;)
            conn.execute(&#39;PRAGMA synchronous = OFF&#39;)  # Use NORMAL if persisting DB
            conn.execute(&#39;PRAGMA cache_size = -64000&#39;)
            conn.execute(&#39;CREATE TABLE IF NOT EXISTS Playlist (show TEXT NOT NULL, settings TEXT)&#39;)
            conn.execute(&#39;CREATE TABLE IF NOT EXISTS Current (playing INTEGER, FOREIGN KEY (playing) REFERENCES Playlist(ROWID))&#39;)
            conn.execute(&#39;INSERT INTO Current VALUES (NULL)&#39;)

    def current_playlist(self) -&gt; list[tuple[int, str]]:
        &#34;&#34;&#34;
        Returns the current playlist of shows. [(id, show),...].
        Uses a list instead of dict to retain ordering.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            cursor = conn.execute(&#39;SELECT rowid, show FROM Playlist ORDER BY rowid&#39;)
            return cursor.fetchall()

    def current_entry(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Returns the entry_id of the playing show, or None.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            cursor = conn.execute(&#39;SELECT playing FROM Current LIMIT 1&#39;)
            return cursor.fetchone()[0]

    def next(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Gets the next show from the playlist.

        Uses the &#39;Current&#39; table to determine the next show on the playlist, and advances the Current show.
        If the Current show is NULL, selects the first item in the playlist.
        If the playlist is empty, returns None.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:  # context manager on the connection
            # Get next show from database.
            cursor = conn.execute(&#39;&#39;&#39;SELECT rowid, show FROM Playlist WHERE rowid &gt;
                IFNULL((SELECT playing FROM Current LIMIT 1),-1)
                LIMIT 1&#39;&#39;&#39;)
            next_show = cursor.fetchone()

            # Handle looping to the first show if we&#39;ve reached the end of the playlist.
            if next_show is None:
                cursor.execute(&#39;SELECT rowid, show FROM Playlist ORDER BY rowid LIMIT 1&#39;)
                next_show = cursor.fetchone()

            # next_show could still be None if Playlist is also empty
            if next_show is None:
                return None

            (entry_id, show) = next_show
            with conn:
                cursor.execute(&#39;UPDATE Current SET playing = (?)&#39;, (entry_id,))
            return show

    def set_next(self, entry_id: int) -&gt; None:
        &#34;&#34;&#34;
        Sets the next show in the playlist to be {entry_id}.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            # Get previous show from database.
            cursor = conn.execute(&#39;SELECT MAX(rowid) FROM Playlist WHERE rowid &lt; (?) LIMIT 1&#39;, (entry_id,))
            prev_id = cursor.fetchone()[0]
            with conn:
                cursor.execute(&#39;UPDATE Current SET playing = (?)&#39;, (prev_id,))

    def append(self, show: str) -&gt; int:
        &#34;&#34;&#34;
        Appends a show to the playlist and returns the new entry_id.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            with conn:
                cursor = conn.execute(&#39;INSERT INTO Playlist VALUES (?, NULL)&#39;, (show,))
                return cursor.lastrowid

    def delete(self, entry_id: int) -&gt; None:
        &#34;&#34;&#34;
        Deletes a show from the playlist.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            with conn:
                conn.execute(&#39;DELETE FROM Playlist WHERE rowid = (?)&#39;, (entry_id,))

    def clear(self) -&gt; None:
        &#34;&#34;&#34;
        Clears the whole playlist.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            with conn:
                cursor = conn.execute(&#39;DELETE FROM Playlist&#39;)
                cursor.execute(&#39;UPDATE Current SET playing = NULL&#39;)

    def get_settings(self, entry_id: int) -&gt; Settings:
        &#34;&#34;&#34;
        Returns the settings for a playlist entry, if any.
        &#34;&#34;&#34;
        with closing(self._connect()) as conn:
            cursor = conn.execute(&#39;SELECT settings FROM Playlist WHERE rowid = (?)&#39;, (entry_id,))
            data = cursor.fetchone()[0]
            return {} if data is None else json.loads(data)

    def set_settings(self, entry_id: int, settings: Settings) -&gt; None:
        &#34;&#34;&#34;
        Sets settings for a playlist entry.
        &#34;&#34;&#34;
        data = json.dumps(settings)
        with closing(self._connect()) as conn:
            with conn:
                conn.execute(&#39;UPDATE Playlist SET settings = (?) WHERE rowid = (?)&#39;, (data, entry_id))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyramidtriangles.playlist.Playlist.setup_database"><code class="name flex">
<span>def <span class="ident">setup_database</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Needs to be called once to set up the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def setup_database(cls):
    &#34;&#34;&#34;Needs to be called once to set up the database.&#34;&#34;&#34;
    global _db_conn_keep_open
    _db_conn_keep_open = cls._connect()
    with _db_conn_keep_open as conn:
        # Pragmas to increase performance from defaults
        conn.execute(&#34;PRAGMA journal_mode = &#39;WAL&#39;&#34;)
        conn.execute(&#39;PRAGMA temp_store = 2&#39;)
        conn.execute(&#39;PRAGMA synchronous = OFF&#39;)  # Use NORMAL if persisting DB
        conn.execute(&#39;PRAGMA cache_size = -64000&#39;)
        conn.execute(&#39;CREATE TABLE IF NOT EXISTS Playlist (show TEXT NOT NULL, settings TEXT)&#39;)
        conn.execute(&#39;CREATE TABLE IF NOT EXISTS Current (playing INTEGER, FOREIGN KEY (playing) REFERENCES Playlist(ROWID))&#39;)
        conn.execute(&#39;INSERT INTO Current VALUES (NULL)&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyramidtriangles.playlist.Playlist.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, show: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a show to the playlist and returns the new entry_id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, show: str) -&gt; int:
    &#34;&#34;&#34;
    Appends a show to the playlist and returns the new entry_id.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        with conn:
            cursor = conn.execute(&#39;INSERT INTO Playlist VALUES (?, NULL)&#39;, (show,))
            return cursor.lastrowid</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the whole playlist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;
    Clears the whole playlist.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        with conn:
            cursor = conn.execute(&#39;DELETE FROM Playlist&#39;)
            cursor.execute(&#39;UPDATE Current SET playing = NULL&#39;)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.current_entry"><code class="name flex">
<span>def <span class="ident">current_entry</span></span>(<span>self) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the entry_id of the playing show, or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_entry(self) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Returns the entry_id of the playing show, or None.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        cursor = conn.execute(&#39;SELECT playing FROM Current LIMIT 1&#39;)
        return cursor.fetchone()[0]</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.current_playlist"><code class="name flex">
<span>def <span class="ident">current_playlist</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current playlist of shows. [(id, show),&hellip;].
Uses a list instead of dict to retain ordering.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_playlist(self) -&gt; list[tuple[int, str]]:
    &#34;&#34;&#34;
    Returns the current playlist of shows. [(id, show),...].
    Uses a list instead of dict to retain ordering.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        cursor = conn.execute(&#39;SELECT rowid, show FROM Playlist ORDER BY rowid&#39;)
        return cursor.fetchall()</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, entry_id: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a show from the playlist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, entry_id: int) -&gt; None:
    &#34;&#34;&#34;
    Deletes a show from the playlist.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        with conn:
            conn.execute(&#39;DELETE FROM Playlist WHERE rowid = (?)&#39;, (entry_id,))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.get_settings"><code class="name flex">
<span>def <span class="ident">get_settings</span></span>(<span>self, entry_id: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the settings for a playlist entry, if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_settings(self, entry_id: int) -&gt; Settings:
    &#34;&#34;&#34;
    Returns the settings for a playlist entry, if any.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        cursor = conn.execute(&#39;SELECT settings FROM Playlist WHERE rowid = (?)&#39;, (entry_id,))
        data = cursor.fetchone()[0]
        return {} if data is None else json.loads(data)</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the next show from the playlist.</p>
<p>Uses the 'Current' table to determine the next show on the playlist, and advances the Current show.
If the Current show is NULL, selects the first item in the playlist.
If the playlist is empty, returns None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Gets the next show from the playlist.

    Uses the &#39;Current&#39; table to determine the next show on the playlist, and advances the Current show.
    If the Current show is NULL, selects the first item in the playlist.
    If the playlist is empty, returns None.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:  # context manager on the connection
        # Get next show from database.
        cursor = conn.execute(&#39;&#39;&#39;SELECT rowid, show FROM Playlist WHERE rowid &gt;
            IFNULL((SELECT playing FROM Current LIMIT 1),-1)
            LIMIT 1&#39;&#39;&#39;)
        next_show = cursor.fetchone()

        # Handle looping to the first show if we&#39;ve reached the end of the playlist.
        if next_show is None:
            cursor.execute(&#39;SELECT rowid, show FROM Playlist ORDER BY rowid LIMIT 1&#39;)
            next_show = cursor.fetchone()

        # next_show could still be None if Playlist is also empty
        if next_show is None:
            return None

        (entry_id, show) = next_show
        with conn:
            cursor.execute(&#39;UPDATE Current SET playing = (?)&#39;, (entry_id,))
        return show</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.set_next"><code class="name flex">
<span>def <span class="ident">set_next</span></span>(<span>self, entry_id: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the next show in the playlist to be {entry_id}.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_next(self, entry_id: int) -&gt; None:
    &#34;&#34;&#34;
    Sets the next show in the playlist to be {entry_id}.
    &#34;&#34;&#34;
    with closing(self._connect()) as conn:
        # Get previous show from database.
        cursor = conn.execute(&#39;SELECT MAX(rowid) FROM Playlist WHERE rowid &lt; (?) LIMIT 1&#39;, (entry_id,))
        prev_id = cursor.fetchone()[0]
        with conn:
            cursor.execute(&#39;UPDATE Current SET playing = (?)&#39;, (prev_id,))</code></pre>
</details>
</dd>
<dt id="pyramidtriangles.playlist.Playlist.set_settings"><code class="name flex">
<span>def <span class="ident">set_settings</span></span>(<span>self, entry_id: int, settings: Settings) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets settings for a playlist entry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_settings(self, entry_id: int, settings: Settings) -&gt; None:
    &#34;&#34;&#34;
    Sets settings for a playlist entry.
    &#34;&#34;&#34;
    data = json.dumps(settings)
    with closing(self._connect()) as conn:
        with conn:
            conn.execute(&#39;UPDATE Playlist SET settings = (?) WHERE rowid = (?)&#39;, (data, entry_id))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyramidtriangles" href="index.html">pyramidtriangles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyramidtriangles.playlist.Playlist" href="#pyramidtriangles.playlist.Playlist">Playlist</a></code></h4>
<ul class="two-column">
<li><code><a title="pyramidtriangles.playlist.Playlist.append" href="#pyramidtriangles.playlist.Playlist.append">append</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.clear" href="#pyramidtriangles.playlist.Playlist.clear">clear</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.current_entry" href="#pyramidtriangles.playlist.Playlist.current_entry">current_entry</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.current_playlist" href="#pyramidtriangles.playlist.Playlist.current_playlist">current_playlist</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.delete" href="#pyramidtriangles.playlist.Playlist.delete">delete</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.get_settings" href="#pyramidtriangles.playlist.Playlist.get_settings">get_settings</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.next" href="#pyramidtriangles.playlist.Playlist.next">next</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.set_next" href="#pyramidtriangles.playlist.Playlist.set_next">set_next</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.set_settings" href="#pyramidtriangles.playlist.Playlist.set_settings">set_settings</a></code></li>
<li><code><a title="pyramidtriangles.playlist.Playlist.setup_database" href="#pyramidtriangles.playlist.Playlist.setup_database">setup_database</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>